--[[
MIT License
Copyright (c) 2025 sigma-axis

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

https://mit-license.org/
]]

@ペンローズタイル モザイクσ
--information:ペンローズタイル モザイクσ v1.22 (for beta20) by σ軸
--label:加工
--check@one_sample:単点サンプル,0
--select@pattern:種類=0,P2(Kite+Dart)=0,P3(菱形2種)=1
--select@center_form:中心の形状=0,Sun=0,Star=1
--track@size:サイズ,2,4000,64,0.01
--track@deflate:再分割,0,35,0,1
--track@rotate:回転,-720,720,0,0.01
--track0:X,-4000,4000,0,0.1
--track1:Y,-4000,4000,0,0.1
--select@edge_style:境界処理=1,なし=0,アンチエイリアス=1,タイル風=2
--value@PI:PI,{}
--[[pixelshader@apply:
Texture2D src : register(t0);
cbuffer constant0 : register(b0) {
	float2x2 rot_scale;
	float2 offset;
	float size, depth_f, pattern,
		pick_one_f, aa_thick, edge_thick;
};

static const float
	phi = 1.618033988749894848,
	phi_sq = 1 + phi,
	phi_i = phi - 1,
	c_1_5th = phi_i / 2,
	s_1_5th = 0.951056516295153572,
	c_2_5th = -phi / 2,
	s_2_5th = 2 * c_1_5th * s_1_5th;
static const float2
	n_1_10th = { s_2_5th, +c_2_5th },
	n_2_10th = { s_1_5th, -c_1_5th },
	n_3_10th = { s_1_5th, +c_1_5th },
	n_4_10th = { s_2_5th, -c_2_5th };
static const float2x3 tr_c5 = {
	1, 0, 0,
	0, -1, 0,
}, tr_c4 = {
	+c_2_5th, +s_2_5th, 0,
	-s_2_5th, +c_2_5th, 0,
}, tr_c2 = {
	+c_1_5th, +s_1_5th, 0,
	-s_1_5th, +c_1_5th, 0,
}, tr_c1 = {
	+c_1_5th, +s_1_5th, 0,
	+s_1_5th, -c_1_5th, 0,
}, tr_c0 = {
	-1, 0, 1,
	0, 1, 0,
}, tr_k0 = {
	-phi * c_1_5th, +phi * s_1_5th, +phi_i * c_1_5th,
	-phi * s_1_5th, -phi * c_1_5th, +phi_i * s_1_5th,
}, tr_k1 = {
	-phi * c_1_5th, +phi * s_1_5th, +phi_i * c_1_5th,
	+phi * s_1_5th, +phi * c_1_5th, -phi_i * s_1_5th,
}, tr_k2 = {
	+phi * c_2_5th, +phi * s_2_5th, -phi * c_2_5th,
	-phi * s_2_5th, +phi * c_2_5th, +phi * s_2_5th,
}, tr_d3 = {
	-phi, 0, 1,
	0, phi, 0,
}, tr_d0 = {
	+phi * c_2_5th, -phi * s_2_5th, phi,
	+phi * s_2_5th, +phi * c_2_5th, 0,
}, tr_w0 = {
	+phi * c_2_5th, -phi * s_2_5th, phi,
	+phi * s_2_5th, +phi * c_2_5th, 0,
}, tr_w3 = {
	-phi * c_2_5th, -phi * s_2_5th, c_2_5th + c_1_5th,
	-phi * s_2_5th, +phi * c_2_5th, s_2_5th + s_1_5th,
}, tr_w1 = {
	-phi, 0, phi_sq,
	0, phi, 0,
}, tr_l2 = {
	-phi * c_1_5th, -phi * s_1_5th, phi,
	+phi * s_1_5th, -phi * c_1_5th, 0,
}, tr_l0 = {
	-phi * c_1_5th, +phi * s_1_5th, +c_1_5th,
	-phi * s_1_5th, -phi * c_1_5th, +s_1_5th,
};

static const int depth = int(depth_f);
static const bool is_P2 = pattern == 0;
float2x4 identify_angle(out int piece, float2 pt)
{
	float2x4 ret = {
		1, 0, 0, pt.x,
		0, 1, 0, pt.y,
	};

	// P2 -> 0: kite / left, 1: kite / right, 2: dart / left, 3: dart / right.
	// P3 -> 0: wide / left, 1: wide / right, 2: long / left, 3: long / right.
	piece = 1;
	if (ret._24 < 0) {
		piece ^= 1;
		ret = mul(tr_c5, float3x4(ret, 0, 0, 1, 1));
	}
	if (dot(ret._14_24, n_4_10th) < 0) ret = mul(tr_c4, float3x4(ret, 0, 0, 1, 1));
	else if (dot(ret._14_24, n_2_10th) < 0) ret = mul(tr_c2, float3x4(ret, 0, 0, 1, 1));
	if (dot(ret._14_24, n_1_10th) < 0) {
		piece ^= 1;
		ret = mul(tr_c1, float3x4(ret, 0, 0, 1, 1));
	}

	return ret;
}
float2x3 identify_piece_P2(out int piece, inout float2 pt)
{
	float2x4 ret = identify_angle(piece, pt);
	piece ^= 1;
	ret = mul(tr_c0, float3x4(ret, 0, 0, 1, 1));

	for (int i = 0; i < depth; i++) {
		if ((piece & 2) == 0) {
			const float2 p = ret._14_24 - float2(2 - phi, 0);
			if (dot(p, n_3_10th) < 0) {
				piece ^= 0;
				ret = mul(tr_k0, float3x4(ret, 0, 0, 1, 1));
			}
			else if (dot(p, n_1_10th) < 0) {
				piece ^= 1;
				ret = mul(tr_k1, float3x4(ret, 0, 0, 1, 1));
			}
			else {
				piece ^= 2;
				ret = mul(tr_k2, float3x4(ret, 0, 0, 1, 1));
			}
		}
		else {
			const float2 p = ret._14_24 - float2(phi_i, 0);
			if (dot(p, n_3_10th) < 0) {
				piece ^= 3;
				ret = mul(tr_d3, float3x4(ret, 0, 0, 1, 1));
			}
			else {
				piece ^= 0;
				ret = mul(tr_d0, float3x4(ret, 0, 0, 1, 1));
			}
		}
	}

	pt = ret._14_24;
	return float2x3(ret._11_12_13, ret._21_22_23);
}

float2x3 identify_piece_P3(out int piece, inout float2 pt)
{
	float2x4 ret = identify_angle(piece, pt);

	for (int i = 0; i < depth; i++) {
		if ((piece & 2) == 0) {
			const float2 p = ret._14_24 - float2(phi_i, 0);
			if (dot(p, n_2_10th) < 0) {
				piece ^= 0;
				ret = mul(tr_w0, float3x4(ret, 0, 0, 1, 1));
			}
			else if (dot(p, n_1_10th) < 0) {
				piece ^= 3;
				ret = mul(tr_w3, float3x4(ret, 0, 0, 1, 1));
			}
			else {
				piece ^= 1;
				ret = mul(tr_w1, float3x4(ret, 0, 0, 1, 1));
			}
		}
		else {
			if (dot(ret._14_24, n_1_10th) < 0) {
				piece ^= 2;
				ret = mul(tr_l2, float3x4(ret, 0, 0, 1, 1));
			}
			else {
				piece ^= 0;
				ret = mul(tr_l0, float3x4(ret, 0, 0, 1, 1));
			}
		}
	}

	pt = ret._14_24;
	return float2x3(ret._11_12_13, ret._21_22_23);
}

float edge_distance_P2(int piece, float2 pt, out float2 n_inner, out float2 mid_edge)
{
	if ((piece & 2) == 0) {
		const float d1 = dot(pt, n_2_10th), d2 = -dot(pt - float2(1, 0), n_4_10th);
		if (d1 < d2) {
			n_inner = n_2_10th; mid_edge = phi_i / 2 * float2(c_1_5th, s_1_5th);
			return d1;
		}
		else {
			n_inner = -n_4_10th; mid_edge = float2(1 + c_2_5th / 2, s_2_5th / 2);
			return d2;
		}
	}
	else {
		const float d1 = dot(pt, n_1_10th), d2 = -dot(pt - float2(phi_i, 0), n_2_10th);
		if (d1 < d2) {
			n_inner = n_1_10th; mid_edge = float2(-c_2_5th, s_2_5th) / 2;
			return d1;
		}
		else {
			n_inner = -n_2_10th; mid_edge = float2(phi_i + c_1_5th / 2, s_1_5th / 2);
			return d2;
		}
	}
}

float edge_distance_P3(int piece, float2 pt, out float2 n_inner, out float2 mid_edge)
{
	if ((piece & 2) == 0) {
		const float d1 = dot(pt, n_1_10th), d2 = -dot(pt - float2(phi, 0), n_4_10th);
		if (d1 < d2) {
			n_inner = n_1_10th; mid_edge = float2(-c_2_5th, s_2_5th) / 2;
			return d1;
		}
		else {
			n_inner = -n_4_10th; mid_edge = float2(phi + c_2_5th / 2, s_2_5th / 2);
			return d2;
		}
	}
	else {
		const float d1 = dot(pt, n_2_10th), d2 = -dot(pt - float2(phi_i, 0), n_3_10th);
		if (d1 < d2) {
			n_inner = n_2_10th; mid_edge = float2(c_1_5th, s_1_5th) / 2;
			return d1;
		}
		else {
			n_inner = -n_3_10th; mid_edge = float2(phi_i - c_1_5th / 2, s_1_5th / 2);
			return d2;
		}
	}
}

float2x3 identify_piece(out int piece, inout float2 pt)
{
	[branch] if (is_P2)
		return identify_piece_P2(piece, pt);
	else return identify_piece_P3(piece, pt);
}

float edge_distance(int piece, float2 pt, out float2 n_inner, out float2 mid_edge)
{
	[branch] if (is_P2)
		return edge_distance_P2(piece, pt, n_inner, mid_edge);
	else return edge_distance_P3(piece, pt, n_inner, mid_edge);
}

float2x2 inv_mat(float2x2 m)
{
	return float2x2(
		+m._22, -m._12,
		-m._21, +m._11
	) / determinant(m);
}
float2x3 inv_map(float2x3 tr)
{
	const float2x2 m = inv_mat(float2x2(tr._11_12, tr._21_22));
	const float2 p = mul(m, -tr._13_23);
	return float2x3(m._11_12, p.x, m._21_22, p.y);
}
float2 rev_map(float2x3 tr, float2 pt)
{
	return mul(inv_mat(float2x2(tr._11_12, tr._21_22)), pt - tr._13_23);
}

int2 tex_size(Texture2D tex)
{
	uint uw, uh; tex.GetDimensions(uw, uh);
	return int2(uw, uh);
}
static const int2 sz_src = tex_size(src);
static const float2x2 map_fig[2][2] = {
	{ { // kite
		+phi_i * c_1_5th, -c_2_5th,
		+phi_i * s_1_5th, -s_2_5th
	}, { // dart
		-c_2_5th, -phi_i * c_1_5th,
		+s_2_5th, -phi_i * s_1_5th
	}}, {{ // wide
		-c_2_5th, -c_2_5th,
		+s_2_5th, -s_2_5th
	}, { // long
		+c_1_5th, +c_1_5th,
		+s_1_5th, -s_1_5th
	}},
};
float4 avg_figure(float2x3 tr_i, float2x2 m)
{
	const float x0 = m._11 + m._12;
	if (pick_one_f == 0) {
		float4 sum = { 0, 0, 0, 0 };
		for (int i = 0; i < 16; i++) {
			for (int j = 0; j < 16; j++) {
				float2 p = mul(m, float2((0.5 + i) / 16, (0.5 + j) / 16));
				if (p.y < 0) p.x = x0 - p.x;
				int2 p_i = int2(mul(tr_i, float3(p, 1)));
				p_i = clamp(p_i, int2(0, 0), sz_src - 1);
				sum += src.Load(int3(p_i, 0));
			}
		}
		return sum / 256;
	}
	else return src.Load(int3(clamp(
		int2(tr_i._11_21 * x0 / 2 + tr_i._13_23),
		int2(0, 0), sz_src - 1), 0));
}

static const float2x2 rot_scale_i = inv_mat(rot_scale);
float4 apply(float4 pos : SV_Position) : SV_Target
{
	float2 pt = mul(rot_scale, pos.xy - offset);

	int piece;
	const float2x3 tr = identify_piece(piece, pt);
	const float2x3 tr_i = mul(
		float2x3(rot_scale_i._11_12, offset.x, rot_scale_i._21_22, offset.y),
		float3x3(inv_map(tr), 0, 0, 1));

	[branch] if (aa_thick > 0) {
		float2 n_inner, pt2;
		const float dist = edge_distance(piece, pt, n_inner, pt2) * size;
		pt2 -= (phi_i * s_2_5th / 4) * n_inner;
		pt2 = mul(tr_i, float3(pt2, 1));

		const float4 col = src.Load(int3(pos.xy, 0));
		float4 colE = col,
			col2 = src.Load(int3(clamp(int2(pt2), int2(0, 0), sz_src - 1), 0));

		n_inner = normalize(mul(float2x2(tr_i._11_12, tr_i._21_22), n_inner));
		const float rate = 0.25 * clamp(edge_thick > 0 ? n_inner.x + n_inner.y : 0, -1, +1);
		colE.rgb = min((1 + rate) * colE.rgb, colE.a);
		col2.rgb = min((1 - rate) * col2.rgb, col2.a);

		return lerp(lerp(col, colE, smoothstep(-aa_thick, 0, edge_thick - dist)),
			col2, smoothstep(-aa_thick / 2, aa_thick / 2, -dist));
	}
	else return avg_figure(tr_i, map_fig[is_P2 ? 0 : 1][piece >> 1]);
}
]]
local obj, math, tonumber = obj, math, tonumber;

-- set anchors.
obj.setanchor("track", 0, "line");

-- take parameters.
--[==[
	PI = {
		one_sample:		boolean|number|nil,
		pattern:		number?,
		center_form:	number?,
		size:			number?,
		deflate:		number?,
		rotate:			number?,
		X:				number?,
		Y:				number?,
		edge_style:		number?,
	}
--]==]
local function as_bool(t, v)
	if type(t) == "boolean" then return t;
	elseif type(t) == "number" then return t ~= 0;
	else return v end
end
one_sample = as_bool(PI.one_sample, one_sample ~= 0);
pattern = tonumber(PI.pattern) or pattern;
center_form = tonumber(PI.center_form) or center_form;
size = tonumber(PI.size) or size;
deflate = tonumber(PI.deflate) or deflate;
rotate = tonumber(PI.rotate) or rotate;
local X = tonumber(PI.X) or obj.track0;
local Y = tonumber(PI.Y) or obj.track1;
edge_style = tonumber(PI.edge_style) or edge_style;

-- normalize parameters.
local kite_dart = math.floor(0.5 + pattern) == 0;
local center_sun = math.floor(0.5 + center_form) == 0;
size = math.max(size, 2);
deflate = math.min(math.max(math.floor(0.5 + deflate), 0), 35);
rotate = math.pi / 180 * rotate;
local dx, dy = X + obj.w / 2, Y + obj.h / 2;
edge_style = math.floor(0.5 + edge_style); if edge_style < 0 or edge_style >= 3 then edge_style = 0 end

-- further calculations.
local phi = (1 + 5 ^ 0.5) / 2;
local extra_depth = math.floor(deflate / 2);
local flip = kite_dart == center_sun and 1 or -1;
if deflate % 2 ~= 0 then
	-- P2 and P3 are swapped.
	if kite_dart or center_sun then flip = -flip end
	if kite_dart then size = size / phi;
	else center_sun = not center_sun end
	kite_dart = not kite_dart;
end
local size_def = phi ^ -extra_depth * size;
if size_def <= 1 then return end
local R = ((math.abs(X) + obj.w / 2) ^ 2 + (math.abs(Y) + obj.h / 2) ^ 2) ^ 0.5;
if kite_dart then
	if center_sun then
		R = R * (4 / 5 * (3 - phi)) ^ 0.5; -- R / \sqrt{1 - 1/4\phi^2}
	else
		R = R * phi;
	end
end
R = math.log(R / size + 1, phi);
local depth = center_sun and
	2 * math.max(0, math.ceil(R / 2)) or
	2 * math.max(0, math.ceil((R - 1) / 2)) + 1;
local size_adj = phi ^ depth * size;
if depth % 4 >= 2 then flip = -flip end

local m11, m12, m21, m22 = 0, flip / size_adj, -flip / size_adj, 0 do
	local c, s = math.cos(rotate), math.sin(rotate);
	m11, m12, m21, m22 =
		-- multiplication of M * (rotation matrix).
		m11 * c - m12 * s, m11 * s + m12 * c,
		m21 * c - m22 * s, m21 * s + m22 * c;
end

-- apply mosaic.
obj.pixelshader("apply", "object", "object",
{
	m11, m21, 0, 0,
	m12, m22;

	dx, dy;
	size_def; depth + extra_depth; kite_dart and 0 or 1;
	one_sample and 1 or 0; 0; 0;
});

-- apply edge effects.
if edge_style ~= 0 then
	obj.pixelshader("apply", "object", "object",
	{
		m11, m21, 0, 0,
		m12, m22;

		dx, dy;
		size_def; depth + extra_depth; kite_dart and 0 or 1; 0;
		edge_style >= 1 and 1 or 0; -- antialias.
		edge_style == 2 and 1 or 0; -- tile-like.
	});
end

@ペンローズタイル ぼかしσ
--information:ペンローズタイル ぼかしσ v1.22 (for beta20) by σ軸
--label:ぼかし
--track@range:範囲,0,1000,5,0.1
--select@pattern:種類=0,P2(Kite+Dart)=0,P3(菱形2種)=1
--select@center_form:中心の形状=0,Sun=0,Star=1
--track@size:サイズ,2,4000,64,0.01
--track@deflate:再分割,0,35,0,1
--track@rotate:回転,-720,720,0,0.01
--track0:X,-4000,4000,0,0.1
--track1:Y,-4000,4000,0,0.1
--select@edge_style:境界処理=1,なし=0,アンチエイリアス=1,タイル風=2
--value@PI:PI,{}
--[[pixelshader@apply:
Texture2D src : register(t0);
cbuffer constant0 : register(b0) {
	float2x2 rot_scale;
	float2 offset;
	float size, depth_f, pattern,
		range, aa_thick, edge_thick;
};

static const float
	phi = 1.618033988749894848,
	phi_sq = 1 + phi,
	phi_i = phi - 1,
	c_1_5th = phi_i / 2,
	s_1_5th = 0.951056516295153572,
	c_2_5th = -phi / 2,
	s_2_5th = 2 * c_1_5th * s_1_5th;
static const float2
	n_1_10th = { s_2_5th, +c_2_5th },
	n_2_10th = { s_1_5th, -c_1_5th },
	n_3_10th = { s_1_5th, +c_1_5th },
	n_4_10th = { s_2_5th, -c_2_5th };
static const float2x3 tr_c5 = {
	1, 0, 0,
	0, -1, 0,
}, tr_c4 = {
	+c_2_5th, +s_2_5th, 0,
	-s_2_5th, +c_2_5th, 0,
}, tr_c2 = {
	+c_1_5th, +s_1_5th, 0,
	-s_1_5th, +c_1_5th, 0,
}, tr_c1 = {
	+c_1_5th, +s_1_5th, 0,
	+s_1_5th, -c_1_5th, 0,
}, tr_c0 = {
	-1, 0, 1,
	0, 1, 0,
}, tr_k0 = {
	-phi * c_1_5th, +phi * s_1_5th, +phi_i * c_1_5th,
	-phi * s_1_5th, -phi * c_1_5th, +phi_i * s_1_5th,
}, tr_k1 = {
	-phi * c_1_5th, +phi * s_1_5th, +phi_i * c_1_5th,
	+phi * s_1_5th, +phi * c_1_5th, -phi_i * s_1_5th,
}, tr_k2 = {
	+phi * c_2_5th, +phi * s_2_5th, -phi * c_2_5th,
	-phi * s_2_5th, +phi * c_2_5th, +phi * s_2_5th,
}, tr_d3 = {
	-phi, 0, 1,
	0, phi, 0,
}, tr_d0 = {
	+phi * c_2_5th, -phi * s_2_5th, phi,
	+phi * s_2_5th, +phi * c_2_5th, 0,
}, tr_w0 = {
	+phi * c_2_5th, -phi * s_2_5th, phi,
	+phi * s_2_5th, +phi * c_2_5th, 0,
}, tr_w3 = {
	-phi * c_2_5th, -phi * s_2_5th, c_2_5th + c_1_5th,
	-phi * s_2_5th, +phi * c_2_5th, s_2_5th + s_1_5th,
}, tr_w1 = {
	-phi, 0, phi_sq,
	0, phi, 0,
}, tr_l2 = {
	-phi * c_1_5th, -phi * s_1_5th, phi,
	+phi * s_1_5th, -phi * c_1_5th, 0,
}, tr_l0 = {
	-phi * c_1_5th, +phi * s_1_5th, +c_1_5th,
	-phi * s_1_5th, -phi * c_1_5th, +s_1_5th,
};

static const int depth = int(depth_f);
static const bool is_P2 = pattern == 0;
float2x4 identify_angle(out int piece, float2 pt)
{
	float2x4 ret = {
		1, 0, 0, pt.x,
		0, 1, 0, pt.y,
	};

	// P2 -> 0: kite / left, 1: kite / right, 2: dart / left, 3: dart / right.
	// P3 -> 0: wide / left, 1: wide / right, 2: long / left, 3: long / right.
	piece = 1;
	if (ret._24 < 0) {
		piece ^= 1;
		ret = mul(tr_c5, float3x4(ret, 0, 0, 1, 1));
	}
	if (dot(ret._14_24, n_4_10th) < 0) ret = mul(tr_c4, float3x4(ret, 0, 0, 1, 1));
	else if (dot(ret._14_24, n_2_10th) < 0) ret = mul(tr_c2, float3x4(ret, 0, 0, 1, 1));
	if (dot(ret._14_24, n_1_10th) < 0) {
		piece ^= 1;
		ret = mul(tr_c1, float3x4(ret, 0, 0, 1, 1));
	}

	return ret;
}
float2x3 identify_piece_P2(out int piece, inout float2 pt)
{
	float2x4 ret = identify_angle(piece, pt);
	piece ^= 1;
	ret = mul(tr_c0, float3x4(ret, 0, 0, 1, 1));

	for (int i = 0; i < depth; i++) {
		if ((piece & 2) == 0) {
			const float2 p = ret._14_24 - float2(2 - phi, 0);
			if (dot(p, n_3_10th) < 0) {
				piece ^= 0;
				ret = mul(tr_k0, float3x4(ret, 0, 0, 1, 1));
			}
			else if (dot(p, n_1_10th) < 0) {
				piece ^= 1;
				ret = mul(tr_k1, float3x4(ret, 0, 0, 1, 1));
			}
			else {
				piece ^= 2;
				ret = mul(tr_k2, float3x4(ret, 0, 0, 1, 1));
			}
		}
		else {
			const float2 p = ret._14_24 - float2(phi_i, 0);
			if (dot(p, n_3_10th) < 0) {
				piece ^= 3;
				ret = mul(tr_d3, float3x4(ret, 0, 0, 1, 1));
			}
			else {
				piece ^= 0;
				ret = mul(tr_d0, float3x4(ret, 0, 0, 1, 1));
			}
		}
	}

	pt = ret._14_24;
	return float2x3(ret._11_12_13, ret._21_22_23);
}

float2x3 identify_piece_P3(out int piece, inout float2 pt)
{
	float2x4 ret = identify_angle(piece, pt);

	for (int i = 0; i < depth; i++) {
		if ((piece & 2) == 0) {
			const float2 p = ret._14_24 - float2(phi_i, 0);
			if (dot(p, n_2_10th) < 0) {
				piece ^= 0;
				ret = mul(tr_w0, float3x4(ret, 0, 0, 1, 1));
			}
			else if (dot(p, n_1_10th) < 0) {
				piece ^= 3;
				ret = mul(tr_w3, float3x4(ret, 0, 0, 1, 1));
			}
			else {
				piece ^= 1;
				ret = mul(tr_w1, float3x4(ret, 0, 0, 1, 1));
			}
		}
		else {
			if (dot(ret._14_24, n_1_10th) < 0) {
				piece ^= 2;
				ret = mul(tr_l2, float3x4(ret, 0, 0, 1, 1));
			}
			else {
				piece ^= 0;
				ret = mul(tr_l0, float3x4(ret, 0, 0, 1, 1));
			}
		}
	}

	pt = ret._14_24;
	return float2x3(ret._11_12_13, ret._21_22_23);
}

float edge_distance_P2(int piece, float2 pt, out float2 n_inner, out float2 mid_edge)
{
	if ((piece & 2) == 0) {
		const float d1 = dot(pt, n_2_10th), d2 = -dot(pt - float2(1, 0), n_4_10th);
		if (d1 < d2) {
			n_inner = n_2_10th; mid_edge = phi_i / 2 * float2(c_1_5th, s_1_5th);
			return d1;
		}
		else {
			n_inner = -n_4_10th; mid_edge = float2(1 + c_2_5th / 2, s_2_5th / 2);
			return d2;
		}
	}
	else {
		const float d1 = dot(pt, n_1_10th), d2 = -dot(pt - float2(phi_i, 0), n_2_10th);
		if (d1 < d2) {
			n_inner = n_1_10th; mid_edge = float2(-c_2_5th, s_2_5th) / 2;
			return d1;
		}
		else {
			n_inner = -n_2_10th; mid_edge = float2(phi_i + c_1_5th / 2, s_1_5th / 2);
			return d2;
		}
	}
}

float edge_distance_P3(int piece, float2 pt, out float2 n_inner, out float2 mid_edge)
{
	if ((piece & 2) == 0) {
		const float d1 = dot(pt, n_1_10th), d2 = -dot(pt - float2(phi, 0), n_4_10th);
		if (d1 < d2) {
			n_inner = n_1_10th; mid_edge = float2(-c_2_5th, s_2_5th) / 2;
			return d1;
		}
		else {
			n_inner = -n_4_10th; mid_edge = float2(phi + c_2_5th / 2, s_2_5th / 2);
			return d2;
		}
	}
	else {
		const float d1 = dot(pt, n_2_10th), d2 = -dot(pt - float2(phi_i, 0), n_3_10th);
		if (d1 < d2) {
			n_inner = n_2_10th; mid_edge = float2(c_1_5th, s_1_5th) / 2;
			return d1;
		}
		else {
			n_inner = -n_3_10th; mid_edge = float2(phi_i - c_1_5th / 2, s_1_5th / 2);
			return d2;
		}
	}
}

float2x3 identify_piece(out int piece, inout float2 pt)
{
	[branch] if (is_P2)
		return identify_piece_P2(piece, pt);
	else return identify_piece_P3(piece, pt);
}

float edge_distance(int piece, float2 pt, out float2 n_inner, out float2 mid_edge)
{
	[branch] if (is_P2)
		return edge_distance_P2(piece, pt, n_inner, mid_edge);
	else return edge_distance_P3(piece, pt, n_inner, mid_edge);
}

float2x2 inv_mat(float2x2 m)
{
	return float2x2(
		+m._22, -m._12,
		-m._21, +m._11
	) / determinant(m);
}
float2x3 inv_map(float2x3 tr)
{
	const float2x2 m = inv_mat(float2x2(tr._11_12, tr._21_22));
	const float2 p = mul(m, -tr._13_23);
	return float2x3(m._11_12, p.x, m._21_22, p.y);
}
float2 rev_map(float2x3 tr, float2 pt)
{
	return mul(inv_mat(float2x2(tr._11_12, tr._21_22)), pt - tr._13_23);
}

int2 tex_size(Texture2D tex)
{
	uint uw, uh; tex.GetDimensions(uw, uh);
	return int2(uw, uh);
}
static const int2 sz_src = tex_size(src);
static const float2x2 map_fig[2][2] = {
	{ { // kite
		+phi_i * c_1_5th, -c_2_5th,
		+phi_i * s_1_5th, -s_2_5th
	}, { // dart
		-c_2_5th, -phi_i * c_1_5th,
		+s_2_5th, -phi_i * s_1_5th
	}}, {{ // wide
		-c_2_5th, -c_2_5th,
		+s_2_5th, -s_2_5th
	}, { // long
		+c_1_5th, +c_1_5th,
		+s_1_5th, -s_1_5th
	}},
};
float4 avg_figure(float2 pos, float2x3 tr, float2x2 m)
{
	static const int max_N = 32;
	static int range_i;
	static const float range_f = modf(min(range, 2 * s_1_5th * size), range_i),
		unit = exp2(0.5 * ceil(2 * log2(max((range_i + 1.0) / max_N, 1))));
	static const int N = round((range_i + 1) / unit),
		range_sq = floor((range_i * range_i) / (unit * unit)),
		range_sq2 = floor((range_i + 1) * (range_i + 1) / (unit * unit));

	const float x0 = m._11 + m._12;
	const float2x2 m_i = inv_mat(m);
	const float2 pos1 = unit * floor((pos - 0.5) / unit) + 0.5;

	float4 sum = src.Load(int3(pos, 0)) / 1024; float sum_wt = 1.0 / 1024;
	for (int i = -N; i <= N; i++) {
		for (int j = -N; j <= N; j++) {
			const float2 pos2 = pos1 + unit * float2(i, j);
			if (pos2.x < 0 || pos2.x >= sz_src.x || pos2.y < 0 || pos2.y >= sz_src.y) continue;
			const int q = i * i + j * j;
			if (q >= range_sq2) continue;
			const float wt = q <= range_sq ? 1 : range_f;

			float2 p = mul(tr, float3(pos2, 1));
			if (p.y < 0) p.x = x0 - p.x;
			p = mul(m_i, p);
			if (0 <= p.x && p.x <= 1 && 0 <= p.y && p.y <= 1) {
				sum += wt * src.Load(int3(pos2, 0));
				sum_wt += wt;
			}
		}
	}
	return sum / sum_wt;
}

static const float2x2 rot_scale_i = inv_mat(rot_scale);
float4 apply(float4 pos : SV_Position) : SV_Target
{
	float2 pt = mul(rot_scale, pos.xy - offset);

	int piece;
	const float2x3 tr = identify_piece(piece, pt);

	[branch] if (aa_thick > 0) {
		const float2x3 tr_i = mul(
			float2x3(rot_scale_i._11_12, offset.x, rot_scale_i._21_22, offset.y),
			float3x3(inv_map(tr), 0, 0, 1));
		float2 n_inner, pt2;
		const float dist = edge_distance(piece, pt, n_inner, pt2) * size;
		pt2 = pt - (dist + 1) / size * n_inner;
		pt2 = mul(tr_i, float3(pt2, 1));

		const float4 col = src.Load(int3(pos.xy, 0));
		float4 colE = col,
			col2 = src.Load(int3(clamp(int2(pt2), int2(0, 0), sz_src - 1), 0));

		n_inner = normalize(mul(float2x2(tr_i._11_12, tr_i._21_22), n_inner));
		const float rate = 0.25 * clamp(edge_thick > 0 ? n_inner.x + n_inner.y : 0, -1, +1);
		colE.rgb = min((1 + rate) * colE.rgb, colE.a);
		col2.rgb = min((1 - rate) * col2.rgb, col2.a);

		return lerp(lerp(col, colE, smoothstep(-aa_thick, 0, edge_thick - dist)),
			col2, smoothstep(-aa_thick / 2, aa_thick / 2, -dist));
	}
	else {
		const float2 ro = -mul(rot_scale, offset);
		const float2x3 tr0 = mul(tr,
			float3x3(rot_scale._11_12, ro.x, rot_scale._21_22, ro.y, 0, 0, 1));
		return avg_figure(pos.xy, tr0, map_fig[is_P2 ? 0 : 1][piece >> 1]);
	}
}
]]
local obj, math, tonumber = obj, math, tonumber;

-- set anchors.
obj.setanchor("track", 0, "line");

-- take parameters.
--[==[
	PI = {
		range:			number?,
		pattern:		number?,
		center_form:	number?,
		size:			number?,
		deflate:		number?,
		rotate:			number?,
		X:				number?,
		Y:				number?,
		edge_style:		number?,
	}
--]==]
range = tonumber(PI.range) or range;
pattern = tonumber(PI.pattern) or pattern;
center_form = tonumber(PI.center_form) or center_form;
size = tonumber(PI.size) or size;
deflate = tonumber(PI.deflate) or deflate;
rotate = tonumber(PI.rotate) or rotate;
local X = tonumber(PI.X) or obj.track0;
local Y = tonumber(PI.Y) or obj.track1;
edge_style = tonumber(PI.edge_style) or edge_style;

-- normalize parameters.
range = math.min(math.max(range, 0), 1000)
local kite_dart = math.floor(0.5 + pattern) == 0;
local center_sun = math.floor(0.5 + center_form) == 0;
size = math.max(size, 2);
deflate = math.min(math.max(math.floor(0.5 + deflate), 0), 35);
rotate = math.pi / 180 * rotate;
local dx, dy = X + obj.w / 2, Y + obj.h / 2;
edge_style = math.floor(0.5 + edge_style); if edge_style < 0 or edge_style >= 3 then edge_style = 0 end
if range <= 0 and edge_style == 0 then return end

-- further calculations.
local phi = (1 + 5 ^ 0.5) / 2;
local extra_depth = math.floor(deflate / 2);
local flip = kite_dart == center_sun and 1 or -1;
if deflate % 2 ~= 0 then
	-- P2 and P3 are swapped.
	if kite_dart or center_sun then flip = -flip end
	if kite_dart then size = size / phi;
	else center_sun = not center_sun end
	kite_dart = not kite_dart;
end
local size_def = phi ^ -extra_depth * size;
if size_def <= 2 then return end
local R = ((math.abs(X) + obj.w / 2) ^ 2 + (math.abs(Y) + obj.h / 2) ^ 2) ^ 0.5;
if kite_dart then
	if center_sun then
		R = R * (4 / 5 * (3 - phi)) ^ 0.5; -- R / \sqrt{1 - 1/4\phi^2}
	else
		R = R * phi;
	end
end
R = math.log(R / size + 1, phi);
local depth = center_sun and
	2 * math.max(0, math.ceil(R / 2)) or
	2 * math.max(0, math.ceil((R - 1) / 2)) + 1;
local size_adj = phi ^ depth * size;
if depth % 4 >= 2 then flip = -flip end

local m11, m12, m21, m22 = 0, flip / size_adj, -flip / size_adj, 0 do
	local c, s = math.cos(rotate), math.sin(rotate);
	m11, m12, m21, m22 =
		-- multiplication of M * (rotation matrix).
		m11 * c - m12 * s, m11 * s + m12 * c,
		m21 * c - m22 * s, m21 * s + m22 * c;
end

-- apply blur.
if range > 0 then
	obj.pixelshader("apply", "object", "object",
	{
		m11, m21, 0, 0,
		m12, m22;

		dx, dy;
		size_def; depth + extra_depth; kite_dart and 0 or 1;
		range; 0; 0;
	});
end

-- apply edge effects.
if edge_style ~= 0 then
	obj.pixelshader("apply", "object", "object",
	{
		m11, m21, 0, 0,
		m12, m22;

		dx, dy;
		size_def; depth + extra_depth; kite_dart and 0 or 1; 0;
		edge_style >= 1 and 1 or 0; -- antialias.
		edge_style == 2 and 1 or 0; -- tile-like.
	});
end

@ペンローズタイル レンズσ
--information:ペンローズタイル レンズσ v1.22 (for beta20) by σ軸
--label:変形
--track@move_x1:移動X1,-5000,5000,0,0.1
--track@move_y1:移動Y1,-5000,5000,0,0.1
--track@rot1:回転1,-720,720,0,0.01
--track@zoom1:拡大率1,-1000,1000,100,0.001
--track@zoom_asp1:拡大縦横比1,-100,100,0,0.01
--track@roundness1:丸み1,0,100,50,0.01
--track@highlight1:ハイライト1,-100,100,25,0.01
--track@move_x2:移動X2,-5000,5000,0,0.1
--track@move_y2:移動Y2,-5000,5000,0,0.1
--track@rot2:回転2,-720,720,0,0.01
--track@zoom2:拡大率2,-1000,1000,100,0.001
--track@zoom_asp2:拡大縦横比2,-100,100,0,0.01
--track@roundness2:丸み2,0,100,50,0.01
--track@highlight2:ハイライト2,-100,100,25,0.01
--track@light_angle:光源角度,-360,360,-45,0.01
--track@back:余白幅,0,1000,0,0.01
--select@pattern:種類=0,P2(Kite+Dart)=0,P3(菱形2種)=1
--select@center_form:中心の形状=0,Sun=0,Star=1
--track@size:サイズ,2,4000,64,0.01
--track@deflate:再分割,0,35,0,1
--track@rotate:回転,-720,720,0,0.01
--track0:X,-4000,4000,0,0.1
--track1:Y,-4000,4000,0,0.1
--select@edge_style:境界処理=2,なし=0,アンチエイリアス=1,タイル風=2
--value@PI:PI,{}
--[[pixelshader@apply:
Texture2D src : register(t0);
struct figure {
	float2x2 rot;
	float2 move, zoom, light_dir;
	float padding, roundness, highlight;
};
cbuffer constant0 : register(b0) {
	figure fig[2];
	float2x2 rot_scale;
	float2 offset;
	float size, depth_f, pattern,
		aa_thick, edge_thick;
};
SamplerState s : register(s0);

static const float
	phi = 1.618033988749894848,
	phi_sq = 1 + phi,
	phi_i = phi - 1,
	c_1_5th = phi_i / 2,
	s_1_5th = 0.951056516295153572,
	c_2_5th = -phi / 2,
	s_2_5th = 2 * c_1_5th * s_1_5th;
static const float2
	n_1_10th = { s_2_5th, +c_2_5th },
	n_2_10th = { s_1_5th, -c_1_5th },
	n_3_10th = { s_1_5th, +c_1_5th },
	n_4_10th = { s_2_5th, -c_2_5th };
static const float2x3 tr_c5 = {
	1, 0, 0,
	0, -1, 0,
}, tr_c4 = {
	+c_2_5th, +s_2_5th, 0,
	-s_2_5th, +c_2_5th, 0,
}, tr_c2 = {
	+c_1_5th, +s_1_5th, 0,
	-s_1_5th, +c_1_5th, 0,
}, tr_c1 = {
	+c_1_5th, +s_1_5th, 0,
	+s_1_5th, -c_1_5th, 0,
}, tr_c0 = {
	-1, 0, 1,
	0, 1, 0,
}, tr_k0 = {
	-phi * c_1_5th, +phi * s_1_5th, +phi_i * c_1_5th,
	-phi * s_1_5th, -phi * c_1_5th, +phi_i * s_1_5th,
}, tr_k1 = {
	-phi * c_1_5th, +phi * s_1_5th, +phi_i * c_1_5th,
	+phi * s_1_5th, +phi * c_1_5th, -phi_i * s_1_5th,
}, tr_k2 = {
	+phi * c_2_5th, +phi * s_2_5th, -phi * c_2_5th,
	-phi * s_2_5th, +phi * c_2_5th, +phi * s_2_5th,
}, tr_d3 = {
	-phi, 0, 1,
	0, phi, 0,
}, tr_d0 = {
	+phi * c_2_5th, -phi * s_2_5th, phi,
	+phi * s_2_5th, +phi * c_2_5th, 0,
}, tr_w0 = {
	+phi * c_2_5th, -phi * s_2_5th, phi,
	+phi * s_2_5th, +phi * c_2_5th, 0,
}, tr_w3 = {
	-phi * c_2_5th, -phi * s_2_5th, c_2_5th + c_1_5th,
	-phi * s_2_5th, +phi * c_2_5th, s_2_5th + s_1_5th,
}, tr_w1 = {
	-phi, 0, phi_sq,
	0, phi, 0,
}, tr_l2 = {
	-phi * c_1_5th, -phi * s_1_5th, phi,
	+phi * s_1_5th, -phi * c_1_5th, 0,
}, tr_l0 = {
	-phi * c_1_5th, +phi * s_1_5th, +c_1_5th,
	-phi * s_1_5th, -phi * c_1_5th, +s_1_5th,
};

static const int depth = int(depth_f);
static const bool is_P2 = pattern == 0;
float2x4 identify_angle(out int piece, float2 pt)
{
	float2x4 ret = {
		1, 0, 0, pt.x,
		0, 1, 0, pt.y,
	};

	// P2 -> 0: kite / left, 1: kite / right, 2: dart / left, 3: dart / right.
	// P3 -> 0: wide / left, 1: wide / right, 2: long / left, 3: long / right.
	piece = 1;
	if (ret._24 < 0) {
		piece ^= 1;
		ret = mul(tr_c5, float3x4(ret, 0, 0, 1, 1));
	}
	if (dot(ret._14_24, n_4_10th) < 0) ret = mul(tr_c4, float3x4(ret, 0, 0, 1, 1));
	else if (dot(ret._14_24, n_2_10th) < 0) ret = mul(tr_c2, float3x4(ret, 0, 0, 1, 1));
	if (dot(ret._14_24, n_1_10th) < 0) {
		piece ^= 1;
		ret = mul(tr_c1, float3x4(ret, 0, 0, 1, 1));
	}

	return ret;
}
float2x3 identify_piece_P2(out int piece, inout float2 pt)
{
	float2x4 ret = identify_angle(piece, pt);
	piece ^= 1;
	ret = mul(tr_c0, float3x4(ret, 0, 0, 1, 1));

	for (int i = 0; i < depth; i++) {
		if ((piece & 2) == 0) {
			const float2 p = ret._14_24 - float2(2 - phi, 0);
			if (dot(p, n_3_10th) < 0) {
				piece ^= 0;
				ret = mul(tr_k0, float3x4(ret, 0, 0, 1, 1));
			}
			else if (dot(p, n_1_10th) < 0) {
				piece ^= 1;
				ret = mul(tr_k1, float3x4(ret, 0, 0, 1, 1));
			}
			else {
				piece ^= 2;
				ret = mul(tr_k2, float3x4(ret, 0, 0, 1, 1));
			}
		}
		else {
			const float2 p = ret._14_24 - float2(phi_i, 0);
			if (dot(p, n_3_10th) < 0) {
				piece ^= 3;
				ret = mul(tr_d3, float3x4(ret, 0, 0, 1, 1));
			}
			else {
				piece ^= 0;
				ret = mul(tr_d0, float3x4(ret, 0, 0, 1, 1));
			}
		}
	}

	pt = ret._14_24;
	return float2x3(ret._11_12_13, ret._21_22_23);
}

float2x3 identify_piece_P3(out int piece, inout float2 pt)
{
	float2x4 ret = identify_angle(piece, pt);

	for (int i = 0; i < depth; i++) {
		if ((piece & 2) == 0) {
			const float2 p = ret._14_24 - float2(phi_i, 0);
			if (dot(p, n_2_10th) < 0) {
				piece ^= 0;
				ret = mul(tr_w0, float3x4(ret, 0, 0, 1, 1));
			}
			else if (dot(p, n_1_10th) < 0) {
				piece ^= 3;
				ret = mul(tr_w3, float3x4(ret, 0, 0, 1, 1));
			}
			else {
				piece ^= 1;
				ret = mul(tr_w1, float3x4(ret, 0, 0, 1, 1));
			}
		}
		else {
			if (dot(ret._14_24, n_1_10th) < 0) {
				piece ^= 2;
				ret = mul(tr_l2, float3x4(ret, 0, 0, 1, 1));
			}
			else {
				piece ^= 0;
				ret = mul(tr_l0, float3x4(ret, 0, 0, 1, 1));
			}
		}
	}

	pt = ret._14_24;
	return float2x3(ret._11_12_13, ret._21_22_23);
}

float edge_distance_P2(int piece, float2 pt, out float2 n_inner, out float2 mid_edge)
{
	if ((piece & 2) == 0) {
		const float d1 = dot(pt, n_2_10th), d2 = -dot(pt - float2(1, 0), n_4_10th);
		if (d1 < d2) {
			n_inner = n_2_10th; mid_edge = phi_i / 2 * float2(c_1_5th, s_1_5th);
			return d1;
		}
		else {
			n_inner = -n_4_10th; mid_edge = float2(1 + c_2_5th / 2, s_2_5th / 2);
			return d2;
		}
	}
	else {
		const float d1 = dot(pt, n_1_10th), d2 = -dot(pt - float2(phi_i, 0), n_2_10th);
		if (d1 < d2) {
			n_inner = n_1_10th; mid_edge = float2(-c_2_5th, s_2_5th) / 2;
			return d1;
		}
		else {
			n_inner = -n_2_10th; mid_edge = float2(phi_i + c_1_5th / 2, s_1_5th / 2);
			return d2;
		}
	}
}

float edge_distance_P3(int piece, float2 pt, out float2 n_inner, out float2 mid_edge)
{
	if ((piece & 2) == 0) {
		const float d1 = dot(pt, n_1_10th), d2 = -dot(pt - float2(phi, 0), n_4_10th);
		if (d1 < d2) {
			n_inner = n_1_10th; mid_edge = float2(-c_2_5th, s_2_5th) / 2;
			return d1;
		}
		else {
			n_inner = -n_4_10th; mid_edge = float2(phi + c_2_5th / 2, s_2_5th / 2);
			return d2;
		}
	}
	else {
		const float d1 = dot(pt, n_2_10th), d2 = -dot(pt - float2(phi_i, 0), n_3_10th);
		if (d1 < d2) {
			n_inner = n_2_10th; mid_edge = float2(c_1_5th, s_1_5th) / 2;
			return d1;
		}
		else {
			n_inner = -n_3_10th; mid_edge = float2(phi_i - c_1_5th / 2, s_1_5th / 2);
			return d2;
		}
	}
}

float2x3 identify_piece(out int piece, inout float2 pt)
{
	[branch] if (is_P2)
		return identify_piece_P2(piece, pt);
	else return identify_piece_P3(piece, pt);
}

float edge_distance(int piece, float2 pt, out float2 n_inner, out float2 mid_edge)
{
	[branch] if (is_P2)
		return edge_distance_P2(piece, pt, n_inner, mid_edge);
	else return edge_distance_P3(piece, pt, n_inner, mid_edge);
}

float2x2 inv_mat(float2x2 m)
{
	return float2x2(
		+m._22, -m._12,
		-m._21, +m._11
	) / determinant(m);
}
float2x3 inv_map(float2x3 tr)
{
	const float2x2 m = inv_mat(float2x2(tr._11_12, tr._21_22));
	const float2 p = mul(m, -tr._13_23);
	return float2x3(m._11_12, p.x, m._21_22, p.y);
}
float2 rev_map(float2x3 tr, float2 pt)
{
	return mul(inv_mat(float2x2(tr._11_12, tr._21_22)), pt - tr._13_23);
}

static const float center_fig[2][2] = {
	{ 2 - phi, phi_i },
	{ phi / 2, phi_i / 2 },
};
float3 height_fig_P2(int piece, float2x3 pt, out float L)
{
	if ((piece >> 1) == 0) {
		const float2x3 pt2 = pt - float2x3(1, 1, 1, 0, 0, 0);
		const float pad = fig[0].padding / size;
		L = max((1 - phi_i) * s_1_5th - pad, 0) * fig[0].roundness;
		const float3
			d1 = smoothstep(-L, 0, -(mul( n_2_10th, pt ) - pad)),
			d2 = smoothstep(-L, 0, -(mul(-n_4_10th, pt2) - pad)),
			d3 = smoothstep(-L, 0, -(mul( n_3_10th, pt ) - pad)),
			d4 = smoothstep(-L, 0, -(mul(-n_1_10th, pt2) - pad));
		return (1 - d1 * d1) * (1 - d2 * d2) * (1 - d3 * d3) * (1 - d4 * d4);
	}
	else {
		const float2x3 pt2 = pt - float2x3(phi_i, phi_i, phi_i, 0, 0, 0);
		const float pad = fig[1].padding / size;
		L = ((2 * phi_i - 1) * s_1_5th - pad) * fig[1].roundness;
		const float2 n = { c_1_5th, s_1_5th };
		const float3
			d1 = smoothstep(-L, 0, -(mul(n_1_10th, pt) - pad)),
			d2 = smoothstep(-L, 0, -(mul(n_4_10th, pt) - pad)),
			d3 = smoothstep(-L, 0, -(float3(
				(dot(n, pt2._11_21) > 0 ? mul(-n_2_10th, pt2._11_21) : length(pt2._11_21)),
				(dot(n, pt2._12_22) > 0 ? mul(-n_2_10th, pt2._11_22) : length(pt2._11_22)),
				(dot(n, pt2._13_23) > 0 ? mul(-n_2_10th, pt2._11_23) : length(pt2._11_23)))
				- pad));
		return (1 - d1 * d1) * (1 - d2 * d2) * (1 - d3 * d3);
	}
}
float3 height_fig_P3(int piece, float2x3 pt, out float L)
{
	const int idx = piece >> 1;
	float2x3 pt2; float2 n1, n2;
	if (idx == 0) {
		pt2 = pt - float2x3(phi, phi, phi, 0, 0, 0);
		n1 = n_1_10th;
		n2 = -n_4_10th;
		L = phi * s_2_5th / 2;
	}
	else {
		pt2 = pt - float2x3(phi_i, phi_i, phi_i, 0, 0, 0);
		n1 = n_2_10th;
		n2 = -n_3_10th;
		L = phi_i * s_1_5th / 2;
	}
	const float pad = fig[idx].padding / size;
	L = (L - pad) * fig[idx].roundness;
	const float3
		d1 = smoothstep(-L, 0, -(mul( n1, pt ) - pad)),
		d2 = smoothstep(-L, 0, -(mul( n2, pt2) - pad)),
		d3 = smoothstep(-L, 0, -(mul(-n2, pt ) - pad)),
		d4 = smoothstep(-L, 0, -(mul(-n1, pt2) - pad));

	return (1 - d1 * d1) * (1 - d2 * d2) * (1 - d3 * d3) * (1 - d4 * d4);
}
float3 height_fig(int piece, float2x3 pt, out float L)
{
	float3 ret = is_P2 ? height_fig_P2(piece, pt, L) : height_fig_P3(piece, pt, L);
	return sqrt(sqrt(ret));
}

int2 tex_size(Texture2D tex)
{
	uint uw, uh; tex.GetDimensions(uw, uh);
	return int2(uw, uh);
}
static const int2 sz_src = tex_size(src);
float4 pick_color(float2 pos)
{
	return src.Sample(s, pos / sz_src);
}

static const float2x2 rot_scale_i = inv_mat(rot_scale);
float4 apply(float4 pos : SV_Position) : SV_Target
{
	float2 pt = mul(rot_scale, pos.xy - offset);

	int piece;
	const float2x3 tr = identify_piece(piece, pt);
	const float2x3 tr_i = mul(
		float2x3(rot_scale_i._11_12, offset.x, rot_scale_i._21_22, offset.y),
		float3x3(inv_map(tr), 0, 0, 1));

	[branch] if (aa_thick > 0) {
		const float2x3 tr_i = mul(
			float2x3(rot_scale_i._11_12, offset.x, rot_scale_i._21_22, offset.y),
			float3x3(inv_map(tr), 0, 0, 1));
		float2 n_inner, pt2;
		const float dist = edge_distance(piece, pt, n_inner, pt2) * size;
		pt2 = pt - (dist + 1) / size * n_inner;
		pt2 = mul(tr_i, float3(pt2, 1));

		const float4 col = src.Load(int3(pos.xy, 0));
		float4 colE = col,
			col2 = src.Load(int3(clamp(int2(pt2), int2(0, 0), sz_src - 1), 0));

		n_inner = normalize(mul(float2x2(tr_i._11_12, tr_i._21_22), n_inner));
		const float rate = 0.25 * clamp(edge_thick > 0 ? n_inner.x + n_inner.y : 0, -1, +1);
		colE.rgb = min((1 + rate) * colE.rgb, colE.a);
		col2.rgb = min((1 - rate) * col2.rgb, col2.a);

		return lerp(lerp(col, colE, smoothstep(-aa_thick, 0, edge_thick - dist)),
			col2, smoothstep(-aa_thick / 2, aa_thick / 2, -dist));
	}
	else {
		const float2x2 tr_m = mul(float2x2(tr._11_12, tr._21_22), rot_scale);
		float L;
		const float3 hts = height_fig(piece, float2x3(
			pt.x, pt.x + tr_m[0],
			pt.y, pt.y + tr_m[1]), L);
		const float height = hts[0], ht_den = max(2 * sqrt(height), 0.0001),
			dx_ht = L * size * (hts[1] - hts[0]) / ht_den,
			dy_ht = L * size * (hts[2] - hts[0]) / ht_den;

		const int idx = piece >> 1;
		const float2 pt2 = float2(center_fig[is_P2 ? 0 : 1][idx], 0);
		pt = mul(((piece & 1) == 0) ? transpose(fig[idx].rot) : fig[idx].rot,
			lerp(1, 1 / fig[idx].zoom, height) * (pt - pt2)) + pt2;
		pt = mul(tr_i, float3(pt, 1)) - fig[idx].move;
		float4 col = pick_color(pt);

		const float3 n = normalize(float3(dx_ht, dy_ht, -1));
		float hl = 2 * dot(fig[idx].light_dir, n.xy) * n.z;
		hl -= clamp(hl, -0.75, 0.75); hl /= 1 - 0.75;
		col.rgb = min(col.rgb + max(fig[idx].highlight * hl, 0), col.a);
		return col;
	}
}
]]
local obj, math, tonumber, type = obj, math, tonumber, type;

-- set anchors.
obj.setanchor("track", 0, "line");

-- take parameters.
--[==[
	PI = {
		move:			array<{ x, y }>|table{ x, y }|number|nil,
		rot:			table|number|nil,
		zoom:			array<{ x, y }>|table{ x, y }|number|nil,
		roundness:		table|number|nil,
		highlight:		table|number|nil,
		light_angle:	table|number|nil,
		back:			table|number|nil,
		pattern:		number?,
		center_form:	number?,
		size:			number?,
		deflate:		number?,
		rotate:			number?,
		X:				number?,
		Y:				number?,
		edge_style:		number?,
	}
--]==]
local function field_as_num(src, tgt, fld)
	local t = src[fld];
	if type(t) == "table" then
		tgt[1][fld], tgt[2][fld] =
			tonumber(t[1]) or tgt[1][fld],
			tonumber(t[2]) or tgt[2][fld];
	elseif type(t) == "number" then
		tgt[1][fld], tgt[2][fld] = t, t;
	end
end
local function field_as_coord(src, tgt, fld)
	local t = src[fld];
	if type(t) == "table" then
		local T1, T2 = type(t[1]), type(t[2]);
		if T1 == "table" and T2 ~= "number" then
			tgt[1][fld][1] = tonumber(t[1][1]) or tgt[1][fld][1];
			tgt[1][fld][2] = tonumber(t[1][2]) or tgt[1][fld][2];
		elseif T1 == "number" and T2 ~= "table" then
			tgt[1][fld][1], tgt[2][fld][1] = t[1], t[1];
		end
		if T2 == "table" and T2 ~= "number" then
			tgt[2][fld][1] = tonumber(t[2][1]) or tgt[2][fld][1];
			tgt[2][fld][2] = tonumber(t[2][2]) or tgt[2][fld][2];
		elseif T2 == "number" and T2 ~= "table" then
			tgt[1][fld][2], tgt[2][fld][2] = t[2], t[2];
		end
	elseif type(t) == "number" then
		tgt[1][fld][1], tgt[2][fld][1], tgt[1][fld][2], tgt[2][fld][2] = t, t, t, t;
	end
end
local function make_zoom(zm, asp)
	local sgn = zm < 0 and -1 or 1;
	zm = math.abs(zm / 100) - 1;
	return
		sgn * 100 * (1 + zm * math.min(math.max(1 - asp, 0), 1)),
		sgn * 100 * (1 + zm * math.min(math.max(1 + asp, 0), 1));
end
local fig = {
	{ move = { move_x1, move_y1 }, rot = rot1, mat = { 1, 0, 0, 1 }, zoom = { make_zoom(zoom1, zoom_asp1 / 100) }, roundness = roundness1, highlight = highlight1, light_angle = light_angle, l_dir = { 0, 1 }, back = back },
	{ move = { move_x2, move_y2 }, rot = rot2, mat = { 1, 0, 0, 1 }, zoom = { make_zoom(zoom2, zoom_asp2 / 100) }, roundness = roundness2, highlight = highlight2, light_angle = light_angle, l_dir = { 0, 1 }, back = back },
};
field_as_coord(PI, fig, "move");
field_as_num(PI, fig, "rot");
field_as_coord(PI, fig, "zoom");
field_as_num(PI, fig, "roundness");
field_as_num(PI, fig, "highlight");
field_as_num(PI, fig, "light_angle");
field_as_num(PI, fig, "back");
pattern = tonumber(PI.pattern) or pattern;
center_form = tonumber(PI.center_form) or center_form;
size = tonumber(PI.size) or size;
deflate = tonumber(PI.deflate) or deflate;
rotate = tonumber(PI.rotate) or rotate;
local X = tonumber(PI.X) or obj.track0;
local Y = tonumber(PI.Y) or obj.track1;
edge_style = tonumber(PI.edge_style) or edge_style;

-- normalize parameters.
for i = 1, #fig do
	local f = fig[i];
	f.rot = math.pi / 180 * f.rot;
	local c, s = math.cos(f.rot), math.sin(f.rot);
	f.mat = { c, -s, s, c };
	f.zoom[1], f.zoom[2] = f.zoom[1] / 100, f.zoom[2] / 100;
	if math.abs(f.zoom[1]) < 0.0001 then
		f.zoom[1] = 0.0001 * (f.zoom[1] < 0 and -1 or 1);
	end
	if math.abs(f.zoom[2]) < 0.0001 then
		f.zoom[2] = 0.0001 * (f.zoom[2] < 0 and -1 or 1);
	end
	f.roundness = math.min(math.max(f.roundness / 100, 0), 1);
	f.highlight = math.min(math.max(f.highlight / 100, -1), 1);
	f.light_angle = math.pi / 180 * f.light_angle;
	c, s = math.cos(f.light_angle), math.sin(f.light_angle);
	f.l_dir = { s, -c };
	f.back = math.max(f.back, 0);
end
local kite_dart = math.floor(0.5 + pattern) == 0;
local center_sun = math.floor(0.5 + center_form) == 0;
size = math.max(size, 2);
deflate = math.min(math.max(math.floor(0.5 + deflate), 0), 35);
rotate = math.pi / 180 * rotate;
local dx, dy = X + obj.w / 2, Y + obj.h / 2;
edge_style = math.floor(0.5 + edge_style); if edge_style < 0 or edge_style >= 3 then edge_style = 0 end

-- further calculations.
local phi = (1 + 5 ^ 0.5) / 2;
local extra_depth = math.floor(deflate / 2);
local flip = kite_dart == center_sun and 1 or -1;
if deflate % 2 ~= 0 then
	-- P2 and P3 are swapped.
	if kite_dart or center_sun then flip = -flip end
	if kite_dart then size = size / phi;
	else center_sun = not center_sun end
	kite_dart = not kite_dart;
end
local size_def = phi ^ -extra_depth * size;
if size_def <= 1 then return end
local R = ((math.abs(X) + obj.w / 2) ^ 2 + (math.abs(Y) + obj.h / 2) ^ 2) ^ 0.5;
if kite_dart then
	if center_sun then
		R = R * (4 / 5 * (3 - phi)) ^ 0.5; -- R / \sqrt{1 - 1/4\phi^2}
	else
		R = R * phi;
	end
end
R = math.log(R / size + 1, phi);
local depth = center_sun and
	2 * math.max(0, math.ceil(R / 2)) or
	2 * math.max(0, math.ceil((R - 1) / 2)) + 1;
local size_adj = phi ^ depth * size;
if depth % 4 >= 2 then flip = -flip end

local m11, m12, m21, m22 = 0, flip / size_adj, -flip / size_adj, 0 do
	local c, s = math.cos(rotate), math.sin(rotate);
	m11, m12, m21, m22 =
		-- multiplication of M * (rotation matrix).
		m11 * c - m12 * s, m11 * s + m12 * c,
		m21 * c - m22 * s, m21 * s + m22 * c;
end

-- apply mosaic.
obj.pixelshader("apply", "object", "object",
{
	fig[1].mat[1], fig[1].mat[2], 0, 0,
	fig[1].mat[3], fig[1].mat[4];
	fig[1].move[1], fig[1].move[2];
	fig[1].zoom[2], fig[1].zoom[1];
	fig[1].l_dir[1], fig[1].l_dir[2];
	fig[1].back, fig[1].roundness, fig[1].highlight; 0;

	fig[2].mat[1], fig[2].mat[2], 0, 0,
	fig[2].mat[3], fig[2].mat[4];
	fig[2].move[1], fig[2].move[2];
	fig[2].zoom[2], fig[2].zoom[1];
	fig[2].l_dir[1], fig[2].l_dir[2];
	fig[2].back, fig[2].roundness, fig[2].highlight; 0;

	m11, m21, 0, 0,
	m12, m22;

	dx, dy;
	size_def; depth + extra_depth; kite_dart and 0 or 1;
	0; 0;
}, "copy", "clamp");

-- apply edge effects.
if edge_style ~= 0 then
	obj.pixelshader("apply", "object", "object",
	{
		fig[1].mat[1], fig[1].mat[2], 0, 0,
		fig[1].mat[3], fig[1].mat[4];
		fig[1].move[1], fig[1].move[2];
		fig[1].zoom[2], fig[1].zoom[1];
		fig[1].l_dir[1], fig[1].l_dir[2];
		fig[1].back, fig[1].roundness, fig[1].highlight; 0;

		fig[2].mat[1], fig[2].mat[2], 0, 0,
		fig[2].mat[3], fig[2].mat[4];
		fig[2].move[1], fig[2].move[2];
		fig[2].zoom[2], fig[2].zoom[1];
		fig[2].l_dir[1], fig[2].l_dir[2];
		fig[2].back, fig[2].roundness, fig[2].highlight; 0;

		m11, m21, 0, 0,
		m12, m22;

		dx, dy;
		size_def; depth + extra_depth; kite_dart and 0 or 1;
		edge_style >= 1 and 1 or 0; -- antialias.
		edge_style == 2 and 1 or 0; -- tile-like.
	}, "copy", "clamp");
end
